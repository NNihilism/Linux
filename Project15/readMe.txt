====================读写锁=================================
读写锁比起mutex具有更高的适用性，具有更高的并行性，可以有多个线程同时占用读模式的读写锁，但是只能有一个线程占用写模式的读写锁，读写锁的三种状态：
1.当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞
2.当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞
3.当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。
    读写锁最适用于对数据结构的读操作次数多于写操作的场合，因为，读模式锁定时可以共享，而写模式锁定时只能某个线程独占资源，因而，读写锁也可以叫做个共享-独占锁。

=================相关函数=================================
1.pthread_rwlock_init(pthread_rwlock_t *rwlock, \ const pthread_rwlockattr_t *attr) 初始化读写锁，成功返回0。初始化成功后，读写锁状态为非所定的。

2.pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) 读锁定读写锁 ，函数成功返回0
若线程写锁定了读写锁，则调用读锁定读写锁函数的线程将无法读锁定读写锁，并将被阻塞，直至可以读锁定。
若同一个线程两次读锁定同一个读写锁，结果无法与测。

3.pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) 写锁定读写锁，函数成功返回0
写锁定读写锁rwlock。如果没有线程读或写锁定读写锁rwlock，当前线程将写锁定读写锁rwlock。否则线程将被阻塞，直到没有线程锁定这个读写锁为止。
如果调用这个函数之前，本线程已经读或写锁定了这个读写锁，那么pthread_rwlock_wrlock函数运行的结果是不可预测的。

读写锁被解开以后，激活阻塞在读写锁上的线程时，往往优先考虑试图写锁定而被阻塞的线程，这样做是为了防止试图写锁定而被阻塞的线程长时间得不到调度。

当一个读写锁被写锁定了，而一个线程阻塞在这个读写锁上时，如果这时来了一个信号，那么当线程从信号处理程序中返回时，将继续阻塞在这个读写锁上。就好像线程没有被中断过。

4.解锁读写锁pthread_rwlock_unlock

　　#include <pthread.h>

　　int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

　　返回值：函数成功返回0；任何其他返回值都表示错误

解锁一个读写锁。


5.释放读写锁pthread_rwlock_destroy

　　#include <pthread.h>

　　int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

　　返回值：函数成功返回0；任何其他返回值都表示错误

释放读写锁rwlock，并释放这个读写锁占用的资源。一般情况下，pthread_rwlock_destroy函数将rwlock指向的互斥锁对象设置为非法值。

释放了一个读写锁之后，在pthread_rwlock_init重新初始化它之前，再使用这个读写锁会有不可预料的结果。

如果有线程锁定了某个读写锁，那么用pthread_rwlock_destroy()函数释放这个读写锁会引起不可预知的结果。

试图释放一个未初始化的读写锁会引起不可预知的结果。
